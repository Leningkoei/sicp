;;;; 2-97
;;;; 2-5-3
;;;; 2022/08/18

;;; a. Implement this algorithm as a procedure `reduce-terms` that takes two
;;; term lists `n` and `d` as arguments and returns a list `nn`, `dd`, which are
;;; `n` and `d` reduced to lowest terms via the algorithm given above. Also
;;; write a procedure `reduce-poly`, analogous to `add-poly`, that checks to see
;;; if the two polys have the same variable. If so, `reduce-poly` strips off the
;;; variable and passes the problem to `reduce-terms`, then reattaches the
;;; variable to the two term lists supplied by `reduce-terms`.

;; answer: term-list:reduce, polynomial:reduce

;;; b. Define a procedure analogous to `reduce-terms` that does what the
;;; original `make-rat` did for integers:

;;; (defun reduce-integers (n d)
;;;   (let ((gcd (gcd n d)))
;;;     `(,(/ n g) ,(/ d g))))

;;; and define `reduce` as a generic operation that calls `apply-generic` to
;;; dispatch to either `reduce-poly` (for `polynomial` arguments) or
;;; `reduce-integers` (for `scheme-number` arguments). You can now easily make
;;; the rational-arithmetic package reduce factions to lowest terms by having
;;; `make-rat` call `reduce` before combing the given numerator and denominator
;;; to form a rational number. The system now handles rational expressions in
;;; either integers or polynomials. To test your program, try the example at the
;;; beginning of this extended exercise:

;;; (defparameter p1 (make-polynomial 'x '((1 1) (0  1))))
;;; (defparameter p2 (make-polynomial 'x '((3 1) (0 -1))))
;;; (defparameter p3 (make-polynomial 'x '((1 1))))
;;; (defparameter p4 (make-polynomial 'x '((2 1) (0 -1))))
;;; 
;;; (defparameter rf1 (make-rational p1 p2))
;;; (defparameter rf2 (make-rational p3 p4))
;;; 
;;; (add rf1 rf2)

;;; See if you get the correct answer, correctly reduced to lowest terms.

;;; The GCD computation is at the heart of any system that does operations on
;;; rational functions. The algorithm used above, although mathematically
;;; straightforward, is extremely slow. The slowness is due partly to the large
;;; number of division operations and party to the enormous size of the
;;; intermediate coefficients generated by the pseudodivisions. One of the
;;; active areas in the development of algebraic-manipulation systems is the
;;; design of better algorithms for computing polynomial GCDs.

;; answer: in common lisp you can use `clos`, def generic and method.

(defpackage term
  (:use :common-lisp))
(in-package :term)

(defun make-term (order coefficient)
  `(term ,order ,coefficient))
(defun term? (term?)
  (eq (car term?) 'term))
(defun order (term)
  (cadr term))
(defun coefficient (term)
  (caddr term))
(defun add (augend addend)
  (if (= (order augend) (order addend))
      (make-term (order augend)
                 (+ (coefficient augend) (coefficient addend)))
      (error (format '() "Terms are not in same order -- ADD-TERM ~A"
                     `(,augend ,addend)))))
(defun negative (term)
  (make-term (order term)
             (- (coefficient term))))
(defun mul (multiplicand multiplier)
  (make-term (+ (order multiplicand) (order multiplier))
             (* (coefficient multiplicand) (coefficient multiplier))))
(defun div (divident divisor)
  (make-term (- (order divident) (order divisor))
             (/ (coefficient divident) (coefficient divisor))))

(export 'make-term)
(export 'term?)
(export 'order)
(export 'coefficient)
(export 'add)
(export 'negative)
(export 'mul)
(export 'div)


(defpackage term-list
  (:use :common-lisp)
  (:import-from :term :make-term)
  (:import-from :term :term?)
  (:import-from :term :order)
  (:import-from :term :coefficient))
(in-package :term-list)

(shadow 'common-lisp:gcd)
(shadow 'common-lisp:reduce)

(defun make-term-list (&rest terms)
  (if (common-lisp:reduce #'(lambda (pre-result term)
                              (if pre-result
                                  (term? term)
                                  '()))
                          `(t . ,terms))
      terms
      (error (format '() "There are something no term type -- MAKE-TERM-LIST ~A"
                     terms))))
(defun empty? (term-list)
  (null term-list))
(defun first-term (term-list)
  (if (empty? term-list)
      (error (format '() "Trying to get first term from a empty term list -- TERM-LIST:FIRST-TERM"))
      (car term-list)))
(defun remove-0-term (rest-term-list)
  (if rest-term-list
      (if (= (coefficient (car rest-term-list)) 0)
          (remove-0-term (cdr rest-term-list))
          `(,(car rest-term-list) .
            ,(remove-0-term (cdr rest-term-list))))
      '()))
(defun adjoin-term (term-list term)
  (remove-0-term
   (if (common-lisp:reduce #'(lambda (pre-result term-in-term-list)
                               (if pre-result
                                   pre-result
                                   (= (order term-in-term-list) (order term))))
                           `(() . ,term-list))
       ;; If there is term in term list with the same order with term.
       ;; Adjoin it.
       (map 'list
            #'(lambda (term-in-term-list)
                (if (= (order term-in-term-list) (order term))
                    (term:add term-in-term-list term)
                    term-in-term-list))
            term-list)
       ;; Push it into a right position.
       (sort `(,term . ,term-list)
             #'(lambda (term-a term-b)
                 (> (order term-a) (order term-b)))))))
(defun add (augend addend)
  (labels ((iterator (newest-augend rest-addend)
             (if rest-addend
                 (iterator (adjoin-term newest-augend (car rest-addend))
                           (cdr rest-addend))
                 newest-augend)))
    (iterator augend addend)))
(defun sub (subtraction subtract)
  (add subtraction (map 'list #'term:negative subtract)))
(defun mul (multiplicand multiplier)
  (common-lisp:reduce #'add
                      (map 'list
                           #'(lambda (term-of-multiplier)
                               (map 'list
                                    #'(lambda (term-of-multiplicand)
                                        (term:mul term-of-multiplicand
                                                  term-of-multiplier))
                                    multiplicand))
                           multiplier)))
(defun div (divident divisor)
  "divident: term-list -> divisor: term-list ->
(quotient: term-list . remainder: term-list)"
  (if (empty? divident)
      ;; divident is a 0 term in term list, and remainder is 0 term in term list.
      `(,(make-term-list) . ,(make-term-list))
      (let ((divident-first-term (first-term divident))
            ( divisor-first-term (first-term  divisor)))
        (if (> (order divisor-first-term) (order divident-first-term))
            `(,(make-term-list) . ,divident)
            (let* ((      quotient*-order (- (order divident-first-term)
                                             (order  divisor-first-term)))
                   (quotient*-coefficient (/ (coefficient divident-first-term)
                                             (coefficient  divisor-first-term)))
                   (quotient* (make-term-list
                               (make-term quotient*-order
                                          quotient*-coefficient)))
                   (substract (mul divisor quotient*))
                   (remainder* (sub divident substract))
                   (rest-result (div remainder* divisor)))
              `(,(add quotient* (car rest-result)) . ,(cdr rest-result)))))))
(defun remainder (divident divisor)
  (cdr (div divident divisor)))
(defun psudoremainder (divident divisor)
  (let* ((o1 (order       (first-term divident)))
         (o2 (order       (first-term  divisor)))
         ( c (coefficient (first-term  divisor)))
         (constant (expt c (+ 1 o1 (- o2)))))
    (cdr (div (mul divident (make-term-list (make-term 0 constant))) divisor))))
(defun gcd (a b)
  (if (empty? b)
      a
      (gcd b (remainder a b))))
(defun gcd-kai (a b)
  (if (empty? b)
      a
      (gcd-kai b (psudoremainder a b))))
(defun gcd-kai-ni (a b)
  (let ((psudoremainder (gcd-kai a b)))
    (let ((gcd (apply #'common-lisp:gcd (map 'list
                                             #'(lambda (term)
                                                 (coefficient term))
                                             psudoremainder))))
      (map 'list
           #'(lambda (term)
               (term:div term (make-term 0 gcd)))
           psudoremainder))))
(defun reduce (n d)
  (let ((gcd (gcd-kai-ni n d)))
    `(,(div n gcd) ,(div d gcd))))

(export 'make-term-list)
(export 'add)
(export 'sub)
(export 'mul)
(export 'div)
(export 'gcd)
(export 'gcd-kai)
(export 'gcd-kai-ni)
(export 'reduce)


(defpackage polynomial
  (:use :common-lisp))
(in-package :polynomial)

(shadow 'common-lisp:variable)
(shadow 'common-lisp:gcd)
(shadow 'common-lisp:reduce)

(defun make-polynomial (variable term-list)
  `(polynomial ,variable ,term-list))
(defun variable (polynomial)
  (cadr polynomial))
(defun term-list (polynomial)
  (caddr polynomial))
(defun variable= (a b)
  (eq a b))
(defmacro with-variable-check (name a b handle-same)
  `(if (variable= (variable ,a) (variable ,b))
       ,handle-same
       (error
        (format '() "Polynomials are not in same variable -- POLYNOMIAL:~A ~A"
                ,name `(,,a ,,b)))))
(defun add (augend addend)
  (with-variable-check 'add augend addend
    (make-polynomial (variable augend)
                     (term-list:add (term-list augend) (term-list addend)))))
(defun sub (subtraction subtract)
  (with-variable-check 'sub subtraction subtract
    (make-polynomial (variable subtraction)
                     (term-list:sub (term-list subtraction)
                                    (term-list subtract   )))))
(defun mul (multiplicand multiplier)
  (with-variable-check 'mul multiplicand multiplier
    (make-polynomial (variable multiplicand)
                     (term-list:mul (term-list multiplicand)
                                    (term-list multiplier)))))
(defun div (divident divisor)
  "divident: polynomial -> divisor: polynomial ->
(quotient: polynomial . remainder: polynomial)"
  (with-variable-check 'div divident divisor
    (let ((result (div (term-list divident) (term-list divisor))))
      `(,(make-polynomial (variable divident) (car result))
        ,(make-polynomial (variable divident) (cdr result))))))
(defun gcd (divident divisor)
  (with-variable-check 'gcd divident divisor
    (make-polynomial (variable divident)
                     (term-list:gcd (term-list divident) (term-list divisor)))))
(defun gcd-kai (divident divisor)
  (with-variable-check 'gcd-kai divident divisor
    (make-polynomial (variable divident)
                     (term-list:gcd-kai (term-list divident) (term-list divisor)))))
(defun gcd-kai-ni (divident divisor)
  (with-variable-check 'gcd-kai-ni divident divisor
    (make-polynomial (variable divident)
                     (term-list:gcd-kai-ni (term-list divident) (term-list divisor)))))
(defun reduce (n d)
  (with-variable-check 'reduce n d
    (make-polynomial (variable n)
                     (term-list:reduce (term-list n) (term-list d)))))

(export 'make-polynomial)
(export 'variable)
(export 'term-list)
(export 'variable=)
(export 'add)
(export 'mul)
(export 'div)
(export 'gcd)
(export 'gcd-kai)
(export 'gcd-kai-ni)
(export 'reduce)


(in-package :common-lisp-user)

(defun make-term (order coefficient)
  (term:make-term order coefficient))
(defun make-term-list (&rest terms)
  (apply #'term-list:make-term-list terms))
(defun make-polynomial (variable term-list)
  (polynomial:make-polynomial variable term-list))

(defun test ()
  (let ((p1 (make-polynomial 'x (make-term-list (make-term 2 1)
                                                (make-term 1 -2)
                                                (make-term 0 1))))
        (p2 (make-polynomial 'x (make-term-list (make-term 2 11)
                                                (make-term 0 7))))
        (p3 (make-polynomial 'x (make-term-list (make-term 1 13)
                                                (make-term 0 7)))))
    (let ((q1 (polynomial:mul p1 p2))
          (q2 (polynomial:mul p1 p3)))
      (print `(gcd        ,(polynomial:gcd        q1 q2)))
      (print `(gcd-kai    ,(polynomial:gcd-kai    q1 q2)))
      (print `(gcd-kai-ni ,(polynomial:gcd-kai-ni q1 q2)))
      '())))
