;;;; A `deque` ("double-ended queue") is a sequence in which items can be
;;;; inserted and deleted at either the front or the rear. Operations on deques
;;;; are the constructor `make-deque`, the predicate `empty-deque?`, selectors
;;;; `front-deque` and `rear-deque`, and mutators `front-insert-deque!`,
;;;; `rear-insert-deque!`, `front-delete-deque!`, and `rear-delete-deque!`. Show
;;;; how to represent deques using pairs, and give implementations of the
;;;; operations. All operations should be accomplished in O(1) steps.

(defun item-value (item)
  (car item))
(defun item-pre (item)
  (car (cdr item)))
(defun item-next (item)
  (cdr (cdr item)))
(defun item-set-value! (item new-value)
  (rplaca item new-value))
(defun item-set-pre! (item new-pre)
  (rplaca (cdr item) new-pre))
(defun item-set-next! (item new-next)
  (rplacd (cdr item) new-next))
(defun make-item (value pre next)
  (cons value (cons pre next)))

(defun front-ptr (deque)
  (car deque))
(defun rear-ptr (deque)
  (cdr deque))
(defun set-front-ptr! (deque item)
  (rplaca deque item))
(defun set-rear-ptr! (deque item)
  (rplacd deque item))
(defun make-deque ()
  (cons nil nil))
(defun empty-deque? (deque)
  (null (front-ptr deque)))

(defun front-insert-deque! (deque value)
  (if (empty-deque? deque)
      (let ((new-item (make-item value nil nil)))
        (set-front-ptr! deque new-item)
        (set-rear-ptr! deque new-item)
        deque)
      (let ((new-item (make-item value nil (front-ptr deque))))
        (item-set-pre! (front-ptr deque) new-item)
        (set-front-ptr! deque new-item)
        deque)))
(defun rear-insert-deque! (deque value)
  (if (empty-deque? deque)
      (let ((new-item (make-item value nil nil)))
        (set-front-ptr! deque new-item)
        (set-rear-ptr! deque new-item)
        deque)
      (let ((new-item (make-item value (rear-ptr deque) nil)))
        (item-set-next! (rear-ptr deque) new-item)
        (set-rear-ptr! deque new-item)
        deque)))
(defun front-delete-deque! (deque)
  (cond ((empty-deque? deque)
         (error (format nil
                        "`front-delete-deque` called with an empty deque ~A"
                        deque)))
        ((eq (front-ptr deque) (rear-ptr deque))
         (set-front-ptr! deque nil) (set-rear-ptr! deque nil) deque)
        (t (set-front-ptr! deque (item-next (front-ptr deque))) deque)))
(defun rear-delete-deque! (deque)
  (cond ((empty-deque? deque)
         (error (format nil
                        "`front-delete-deque` called with an empty deque ~A"
                        deque)))
        ((eq (front-ptr deque) (rear-ptr deque))
         (set-front-ptr! deque nil) (set-rear-ptr! deque nil) deque)
        (t (set-rear-ptr! deque (item-pre (rear-ptr deque))) deque)))

(defun deque-print (deque)
  (format t "DEQUE: ")
  (labels ((iterator (rest-deque)
             (if (null rest-deque)
                 (fresh-line)
                 (progn (format t "~A " (item-value rest-deque))
                        (iterator (item-next rest-deque))))))
    (iterator (front-ptr deque))))

(defun test ()
  (let ((deque (make-deque)))
    (front-insert-deque! deque 2)
    (rear-insert-deque!  deque 3)
    (front-insert-deque! deque 1)
    (rear-insert-deque!  deque 4)
    (deque-print deque)
    (front-delete-deque! deque)
    (rear-delete-deque! deque)
    (front-delete-deque! deque)
    (rear-delete-deque! deque)
    (deque-print deque)))
